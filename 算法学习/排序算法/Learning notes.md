# 排序算法

***为避免stl库中的便捷算法函数影响到本身算法的学习 所有的算法实现代码均未采用stl库中的容器和算法***

***每个算法对应文件夹中，包含一个基础算法代码，和一个算法优化后的代码（若有）***

## 选择排序

给定一组数据，首先从第一个数据开始往后遍历，找到一个最小的，与第一个元素交换，这样第一个元素就是所有数据中最小的，接着从第二个元素开始往后遍历，找到一个最小的元素，与第二个元素交换，得到第二个元素是所有数据中第二小的，以此类推，当遍历到倒数第二个数据时，就得到了一组升序的数据。

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 简单直观，易于实现
- 不适合大规模排序
- 交换次数少（最多n-1次交换）

优化：进行双向选择排序，每次将最小的交换到前面，将最大的交换到后面



## 冒泡排序

给定一组数据，从第一个数据开始，将该数据与后一个数据进行比较，若后一个数据小于前一个数据则交换两个数据，接下来比较下一个位置的数据与其下一个数据，进行完一轮后，可以将最大的一个数据排在最后面，接下来重复操作，得到第二大的数组在倒数第二个位置，以此类推，最后可以得到一组升序的数据

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 稳定排序，简单直观
- 性能较差，交换频繁

优化：遍历记录是否交换，若没有发生交换，则证明已经为有序数据，直接终止循环；同时记录每次最后交换的位置，设为下一轮排序的终止边界，终止边界后的数据以及排列好，无需重新遍历



## 插入排序

给定一组数据，从第二个数据开始与第一个数据比较，若第二个数据小于第一个数据，则交换两个数据，接着将第三个数据依次与前面两个数据比较，将第三个数据插入到对应位置上，以此类推，进行n-1次遍历循环后可以得到一组升序数据

时间复杂度：***O($n^2$)***    空间复杂度：***O(1)***

特点：

- 稳定排序，适应性强（对部分有序数据效率高）
- 小规模数据表现优异，实际性能通常优于冒泡和选择排序

优化：若数据较多，可引入二分查找比较，将时间复杂度将为***O($nlogn$)***

