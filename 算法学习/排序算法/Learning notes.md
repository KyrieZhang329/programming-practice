# 排序算法

***为避免stl库中的便捷算法函数影响到本身算法的学习 所有的算法实现代码均未采用stl库中的排序算法***

***每个算法对应文件夹中，包含一个基础算法代码，和一个算法优化后的代码（若有）***

[TOC]

## 选择排序

给定一组数据，首先从第一个数据开始往后遍历，找到一个最小的，与第一个元素交换，这样第一个元素就是所有数据中最小的，接着从第二个元素开始往后遍历，找到一个最小的元素，与第二个元素交换，得到第二个元素是所有数据中第二小的，以此类推，当遍历到倒数第二个数据时，就得到了一组升序的数据。

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 简单直观，易于实现
- 不适合大规模排序
- 交换次数少（最多n-1次交换）

优化：进行双向选择排序，每次将最小的交换到前面，将最大的交换到后面



## 冒泡排序

给定一组数据，从第一个数据开始，将该数据与后一个数据进行比较，若后一个数据小于前一个数据则交换两个数据，接下来比较下一个位置的数据与其下一个数据，进行完一轮后，可以将最大的一个数据排在最后面，接下来重复操作，得到第二大的数组在倒数第二个位置，以此类推，最后可以得到一组升序的数据

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 稳定排序，简单直观
- 性能较差，交换频繁

优化：遍历记录是否交换，若没有发生交换，则证明已经为有序数据，直接终止循环；同时记录每次最后交换的位置，设为下一轮排序的终止边界，终止边界后的数据以及排列好，无需重新遍历



## 插入排序

给定一组数据，从第二个数据开始与第一个数据比较，若第二个数据小于第一个数据，则交换两个数据，接着将第三个数据依次与前面两个数据比较，将第三个数据插入到对应位置上，以此类推，进行n-1次遍历循环后可以得到一组升序数据

时间复杂度：***O($n^2$)***    空间复杂度：***O(1)***

特点：

- 稳定排序，适应性强（对部分有序数据效率高）
- 小规模数据表现优异，实际性能通常优于冒泡和选择排序

优化：若数据较多，可引入二分查找比较，将时间复杂度降为***O($nlogn$)***



## 归并排序

### 递归实现

给定一组数据，递归不断将数组从中间分成两个子数组，直到最小，再递归对左子数组进行排序，再递归对右子数组进行排序，最后将两个已排序的子数组合并成一个有序数组。合并过程通过比较两个子数组的元素，按顺序将较小的元素放入临时数组，最后将临时数组复制回原数组，得到一组升序数据。

时间复杂度：***O($n\log n$)***     空间复杂度：***O($n$)***

特点：
- 稳定排序，保持相同元素的相对顺序
- 性能稳定，不受输入数据分布影响
- 符合分治思想
- 递归调用可能导致栈溢出（对极大数组）

### 迭代实现

给定一组数据，首先将每个元素视为一个长度为1的有序子数组，然后两两合并成长度为2的有序子数组，接着将这些子数组两两合并成长度为4的有序子数组，以此类推，每次合并后子数组长度翻倍，直到整个数组有序。合并过程使用临时数组存储结果，通过循环控制每次合并的子数组长度和位置，无需递归调用。

时间复杂度：***O($n\log n$)***     空间复杂度：***O($n$)***

特点：
- 稳定排序，保持相同元素的相对顺序
- 无递归开销，不会导致栈溢出
- 对缓存更友好，性能通常优于递归版本

优化：可并行处理不相交的子数组合并操作；根据数据特性动态调整合并策略，避免不必要的合并操作。



