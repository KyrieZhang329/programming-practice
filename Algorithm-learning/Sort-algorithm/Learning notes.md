# 排序算法

***为避免stl库中的便捷算法函数影响到本身算法的学习 所有的算法实现代码均未采用stl库中的排序算法***

***每个算法对应文件夹中，包含一个基础算法代码，和一个算法优化后的代码（若有）***

[TOC]

## 选择排序

给定一组数据，首先从第一个数据开始往后遍历，找到一个最小的，与第一个元素交换，这样第一个元素就是所有数据中最小的，接着从第二个元素开始往后遍历，找到一个最小的元素，与第二个元素交换，得到第二个元素是所有数据中第二小的，以此类推，当遍历到倒数第二个数据时，就得到了一组升序的数据。

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 简单直观，易于实现
- 不适合大规模排序
- 交换次数少（最多n-1次交换）

优化：进行双向选择排序，每次将最小的交换到前面，将最大的交换到后面



## 冒泡排序

给定一组数据，从第一个数据开始，将该数据与后一个数据进行比较，若后一个数据小于前一个数据则交换两个数据，接下来比较下一个位置的数据与其下一个数据，进行完一轮后，可以将最大的一个数据排在最后面，接下来重复操作，得到第二大的数组在倒数第二个位置，以此类推，最后可以得到一组升序的数据

时间复杂度：***O($n^2$)***     空间复杂度：***O($1$)***

特点：

- 稳定排序，简单直观
- 性能较差，交换频繁

优化：遍历记录是否交换，若没有发生交换，则证明已经为有序数据，直接终止循环；同时记录每次最后交换的位置，设为下一轮排序的终止边界，终止边界后的数据以及排列好，无需重新遍历



## 插入排序

给定一组数据，从第二个数据开始与第一个数据比较，若第二个数据小于第一个数据，则交换两个数据，接着将第三个数据依次与前面两个数据比较，将第三个数据插入到对应位置上，以此类推，进行n-1次遍历循环后可以得到一组升序数据

时间复杂度：***O($n^2$)***    空间复杂度：***O(1)***

特点：

- 稳定排序，适应性强（对部分有序数据效率高）
- 小规模数据表现优异，实际性能通常优于冒泡和选择排序

优化：若数据较多，可引入二分查找比较，将时间复杂度降为***O($nlogn$)***



## 归并排序

### 递归实现

给定一组数据，递归不断将数组从中间分成两个子数组，直到最小，再递归对左子数组进行排序，再递归对右子数组进行排序，最后将两个已排序的子数组合并成一个有序数组。合并过程通过比较两个子数组的元素，按顺序将较小的元素放入临时数组，最后将临时数组复制回原数组，得到一组升序数据。

时间复杂度：***O($n\log n$)***     空间复杂度：***O($n$)***

特点：
- 稳定排序，保持相同元素的相对顺序
- 性能稳定，不受输入数据分布影响
- 符合分治思想
- 递归调用可能导致栈溢出（对极大数组）

### 迭代实现

给定一组数据，首先将每个元素视为一个长度为1的有序子数组，然后两两合并成长度为2的有序子数组，接着将这些子数组两两合并成长度为4的有序子数组，以此类推，每次合并后子数组长度翻倍，直到整个数组有序。合并过程使用临时数组存储结果，通过循环控制每次合并的子数组长度和位置，无需递归调用。

时间复杂度：***O($n\log n$)***     空间复杂度：***O($n$)***

特点：
- 稳定排序，保持相同元素的相对顺序
- 无递归开销，不会导致栈溢出
- 对缓存更友好，性能通常优于递归版本

优化：可并行处理不相交的子数组合并操作；根据数据特性动态调整合并策略，避免不必要的合并操作。



## 桶排序

给定一组数据，首先确定数据的范围（最大值和最小值），然后创建一定数量的桶。将每个元素根据其值映射到对应的桶中，这个映射通常通过公式`index = (value - min) / (max - min + 1) * bucket_count`计算。接着对每个非空桶内的元素进行单独排序（通常使用其他排序算法如插入排序或快速排序）。最后，按顺序遍历所有桶，将桶中的元素依次合并回原始数组，从而得到一个有序序列。

时间复杂度：

- 平均情况：***O(n+k)***
- 空间复杂度：***O(n+k)***（n为元素个数，k为桶的数量）

特点：

- 非常适合处理数据均匀分布的情况
- 可以高效处理浮点数排序
- 是稳定的排序算法（当桶内排序也是稳定时）
- 需要额外空间存储桶
- 对数据分布敏感，不均匀分布时性能下降明显
- 并行处理友好，不同桶可以独立排序



## 计数排序

给定一组数据，首先找出数据的最大值，然后创建一个从最小值到最大值的计数数组。遍历原始数据，统计每个元素出现的次数并记录在计数数组中。接着，对计数数组进行累加，计算出每个元素在最终排序结果中的正确位置。最后，根据这些位置信息将原始数据放置到输出数组中，得到有序序列。

时间复杂度：***O(n + k)***     空间复杂度：***O(n + k)***

特点：

- 非比较型排序，在数据范围k不大时速度极快
- 稳定排序
- 空间消耗大，是典型的空间换时间算法
- 对数据范围敏感，仅适用于相同数据类型的映射
